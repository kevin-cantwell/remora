// Package blockchain provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package blockchain

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/pkg/errors"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for DepositInfoState.
const (
	DepositInfoStateCOMPLETED DepositInfoState = "COMPLETED"

	DepositInfoStateREJECTED DepositInfoState = "REJECTED"

	DepositInfoStateUNCONFIRMED DepositInfoState = "UNCONFIRMED"
)

// Defines values for OrderStatus.
const (
	OrderStatusCANCELED OrderStatus = "CANCELED"

	OrderStatusEXPIRED OrderStatus = "EXPIRED"

	OrderStatusFILLED OrderStatus = "FILLED"

	OrderStatusOPEN OrderStatus = "OPEN"

	OrderStatusPARTFILLED OrderStatus = "PART_FILLED"

	OrderStatusREJECTED OrderStatus = "REJECTED"
)

// Defines values for SymbolStatusStatus.
const (
	SymbolStatusStatusClose SymbolStatusStatus = "close"

	SymbolStatusStatusHalt SymbolStatusStatus = "halt"

	SymbolStatusStatusHaltFreeze SymbolStatusStatus = "halt-freeze"

	SymbolStatusStatusOpen SymbolStatusStatus = "open"

	SymbolStatusStatusSuspend SymbolStatusStatus = "suspend"
)

// Defines values for TimeInForce.
const (
	TimeInForceFOK TimeInForce = "FOK"

	TimeInForceGTC TimeInForce = "GTC"

	TimeInForceGTD TimeInForce = "GTD"

	TimeInForceIOC TimeInForce = "IOC"
)

// Defines values for WithdrawalStatus.
const (
	WithdrawalStatusCOMPLETED WithdrawalStatus = "COMPLETED"

	WithdrawalStatusFAILED WithdrawalStatus = "FAILED"

	WithdrawalStatusPENDING WithdrawalStatus = "PENDING"

	WithdrawalStatusREFUNDED WithdrawalStatus = "REFUNDED"

	WithdrawalStatusREJECTED WithdrawalStatus = "REJECTED"
)

// Defines values for OrdType.
const (
	OrdTypeLIMIT OrdType = "LIMIT"

	OrdTypeMARKET OrdType = "MARKET"

	OrdTypeSTOP OrdType = "STOP"

	OrdTypeSTOPLIMIT OrdType = "STOPLIMIT"
)

// Defines values for Side.
const (
	SideBUY Side = "BUY"

	SideSELL Side = "SELL"
)

// Balance defines model for Balance.
type Balance struct {
	Available      float64  `json:"available"`
	AvailableLocal float64  `json:"available_local"`
	Balance        float64  `json:"balance"`
	BalanceLocal   float64  `json:"balance_local"`
	Currency       Currency `json:"currency"`
	Rate           float64  `json:"rate"`
}

// BalanceList defines model for BalanceList.
type BalanceList []Balance

// BalanceMap defines model for BalanceMap.
type BalanceMap struct {
	Primary              BalanceList            `json:"primary"`
	AdditionalProperties map[string]BalanceList `json:"-"`
}

// BaseOrder defines model for BaseOrder.
type BaseOrder struct {

	// Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
	ClOrdId ClientOrderId `json:"clOrdId"`

	// expiry date in the format YYYYMMDD
	ExpireDate *ExpireDate `json:"expireDate,omitempty"`

	// The minimum quantity required for an IOC fill
	MinQty  *MinQty `json:"minQty,omitempty"`
	OrdType OrdType `json:"ordType"`

	// The order size in the terms of the base currency
	OrderQty OrderQty `json:"orderQty"`

	// The limit price for the order
	Price *Price `json:"price,omitempty"`

	// "buy" for Buy, "sell" for Sell
	Side Side `json:"side"`

	// The limit price for the order
	StopPx *Price `json:"stopPx,omitempty"`

	// Blockchain symbol identifier
	Symbol Symbol `json:"symbol"`

	// "GTC" for Good Till Cancel, "IOC" for Immediate or Cancel, "FOK" for Fill or Kill, "GTD" Good Till Date
	TimeInForce *TimeInForce `json:"timeInForce,omitempty"`
}

// Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
type ClientOrderId string

// CreateWithdrawalRequest defines model for CreateWithdrawalRequest.
type CreateWithdrawalRequest struct {

	// The amount to withdraw in the currency specified
	Amount      *WithdrawalAmount     `json:"amount,omitempty"`
	Beneficiary WithdrawalBeneficiary `json:"beneficiary"`
	Currency    Currency              `json:"currency"`

	// If set, sends the full available amount, minus fees. Amount may not be specified in that case.
	SendMax *bool `json:"sendMax,omitempty"`
}

// Address to deposit to. If a tag or memo must be used, it is separated by a colon.
type CryptoAddress string

// DepositAddressCrypto defines model for DepositAddressCrypto.
type DepositAddressCrypto struct {

	// Address to deposit to. If a tag or memo must be used, it is separated by a colon.
	Address string `json:"address"`
	Type    string `json:"type"`
}

// Unique ID for this withdrawal
type DepositId string

// DepositInfo defines model for DepositInfo.
type DepositInfo struct {

	// Address to deposit to. If a tag or memo must be used, it is separated by a colon.
	Address CryptoAddress `json:"address"`

	// The amount that is credited in the currency specified
	Amount   float64  `json:"amount"`
	Currency Currency `json:"currency"`

	// Unique ID for this withdrawal
	DepositId DepositId        `json:"depositId"`
	State     DepositInfoState `json:"state"`

	// Time in ms since 01/01/1970 (epoch)
	Timestamp *TimestampEpoch `json:"timestamp,omitempty"`

	// The transaction hash of the transaction that deposited funds
	TxHash *string `json:"txHash,omitempty"`
}

// DepositInfoState defines model for DepositInfo.State.
type DepositInfoState string

// The unique order id assigned by the exchange
type ExchangeOrderId int64

// The unique execution report id assigned by the exchange
type ExecId int64

// Fees defines model for Fees.
type Fees struct {
	MakerRate   float64 `json:"makerRate"`
	TakerRate   float64 `json:"takerRate"`
	VolumeInUSD float64 `json:"volumeInUSD"`
}

// Fill defines model for Fill.
type Fill struct {

	// The unique order id assigned by the exchange
	ExOrdId ExchangeOrderId `json:"exOrdId"`

	// The unique execution report id assigned by the exchange
	ExecId ExecId `json:"execId"`

	// The fee charged for this fill
	Fee float64 `json:"fee"`

	// The limit price for the order
	Price Price `json:"price"`

	// The trade size in the terms of the base currency
	Qty float64 `json:"qty"`

	// "buy" for Buy, "sell" for Sell
	Side Side `json:"side"`

	// Blockchain symbol identifier
	Symbol Symbol `json:"symbol"`

	// Time in ms since 01/01/1970 (epoch)
	Timestamp TimestampEpoch `json:"timestamp"`

	// The unique trade id assigned by the exchange
	TradeId TradeId `json:"tradeId"`
}

// OrderBook defines model for OrderBook.
type OrderBook struct {
	Asks *[]OrderBookEntry `json:"asks,omitempty"`
	Bids *[]OrderBookEntry `json:"bids,omitempty"`

	// Blockchain symbol identifier
	Symbol *Symbol `json:"symbol,omitempty"`
}

// OrderBookEntry defines model for OrderBookEntry.
type OrderBookEntry struct {

	// Either the quantity of orders on this price level for L2, or the individual order id for L3
	Num *int64   `json:"num,omitempty"`
	Px  *float64 `json:"px,omitempty"`
	Qty *float64 `json:"qty,omitempty"`
}

// OrderStatus defines model for OrderStatus.
type OrderStatus string

// OrderSummary defines model for OrderSummary.
type OrderSummary struct {

	// Calculated the Volume Weighted Average Price of all fills for this order
	AvgPx *float64 `json:"avgPx,omitempty"`

	// Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
	ClOrdId ClientOrderId `json:"clOrdId"`

	// The quantity of the order which has been filled
	CumQty *float64 `json:"cumQty,omitempty"`

	// The unique order id assigned by the exchange
	ExOrdId *ExchangeOrderId `json:"exOrdId,omitempty"`

	// The executed price for the last fill
	LastPx *float64 `json:"lastPx,omitempty"`

	// The executed quantity for the order's last fill
	LastShares *float64 `json:"lastShares,omitempty"`

	// For Open and Partially Filled orders this is the remaining quantity open for execution. For Canceled and Expired orders this is the quantity than was still open before cancellation/expiration. For Rejected order this is equal to orderQty. For other states this is always zero.
	LeavesQty *float64    `json:"leavesQty,omitempty"`
	OrdStatus OrderStatus `json:"ordStatus"`
	OrdType   OrdType     `json:"ordType"`

	// The limit price for the order
	Price *Price `json:"price,omitempty"`

	// "buy" for Buy, "sell" for Sell
	Side Side `json:"side"`

	// Blockchain symbol identifier
	Symbol Symbol `json:"symbol"`

	// The reason for rejecting the order, if applicable
	Text *string `json:"text,omitempty"`

	// Time in ms since 01/01/1970 (epoch)
	Timestamp *TimestampEpoch `json:"timestamp,omitempty"`
}

// PriceEvent defines model for PriceEvent.
type PriceEvent struct {
	LastTradePrice *float64 `json:"last_trade_price,omitempty"`
	Price24h       *float64 `json:"price_24h,omitempty"`

	// Blockchain symbol identifier
	Symbol    *Symbol  `json:"symbol,omitempty"`
	Volume24h *float64 `json:"volume_24h,omitempty"`
}

// SymbolStatus defines model for SymbolStatus.
type SymbolStatus struct {

	// If the symbol is halted and will open on an auction, this will be the opening price.
	AuctionPrice *float64 `json:"auction_price,omitempty"`

	// Opening size
	AuctionSize *float64 `json:"auction_size,omitempty"`

	// Opening time in HHMM format
	AuctionTime *string `json:"auction_time,omitempty"`

	// Blockchain symbol identifier
	BaseCurrency *Symbol `json:"base_currency,omitempty"`

	// The number of decimals the currency can be split in
	BaseCurrencyScale *int `json:"base_currency_scale,omitempty"`

	// Blockchain symbol identifier
	CounterCurrency *Symbol `json:"counter_currency,omitempty"`

	// The number of decimals the currency can be split in
	CounterCurrencyScale *int   `json:"counter_currency_scale,omitempty"`
	Id                   *int64 `json:"id,omitempty"`

	// Auction imbalance. If > 0 then there will be buy orders left over at the auction price. If < 0 then there will be sell orders left over at the auction price.
	Imbalance    *float64 `json:"imbalance,omitempty"`
	LotSize      *int64   `json:"lot_size,omitempty"`
	LotSizeScale *int     `json:"lot_size_scale,omitempty"`

	// The maximum quantity for an order for this instrument is max_order_size*(10^-max_order_size_scale). If this equal to zero, there is no limit
	MaxOrderSize      *int64 `json:"max_order_size,omitempty"`
	MaxOrderSizeScale *int   `json:"max_order_size_scale,omitempty"`

	// The minimum quantity for an order for this instrument must be min_order_size*(10^-min_order_size_scale)
	MinOrderSize      *int64 `json:"min_order_size,omitempty"`
	MinOrderSizeScale *int   `json:"min_order_size_scale,omitempty"`

	// The price of the instrument must be a multiple of min_price_increment * (10^-min_price_increment_scale)
	MinPriceIncrement      *int64 `json:"min_price_increment,omitempty"`
	MinPriceIncrementScale *int   `json:"min_price_increment_scale,omitempty"`

	// Symbol status; open, close, suspend, halt, halt-freeze.
	Status *SymbolStatusStatus `json:"status,omitempty"`
}

// Symbol status; open, close, suspend, halt, halt-freeze.
type SymbolStatusStatus string

// "GTC" for Good Till Cancel, "IOC" for Immediate or Cancel, "FOK" for Fill or Kill, "GTD" Good Till Date
type TimeInForce string

// Time in ms since 01/01/1970 (epoch)
type TimestampEpoch int64

// The unique trade id assigned by the exchange
type TradeId int64

// WhitelistEntry defines model for WhitelistEntry.
type WhitelistEntry struct {
	Currency *Currency `json:"currency,omitempty"`

	// User specified name for this entry
	Name *string `json:"name,omitempty"`

	// Unique ID for each whitelist entry
	WhitelistId *string `json:"whitelistId,omitempty"`
}

// The amount to withdraw in the currency specified
type WithdrawalAmount float64

// WithdrawalBeneficiary defines model for WithdrawalBeneficiary.
type WithdrawalBeneficiary string

// The amount charged in fees for this withdrawal
type WithdrawalFee float64

// Unique ID for this withdrawal
type WithdrawalId string

// WithdrawalInfo defines model for WithdrawalInfo.
type WithdrawalInfo struct {

	// The amount to withdraw in the currency specified
	Amount      WithdrawalAmount      `json:"amount"`
	Beneficiary WithdrawalBeneficiary `json:"beneficiary"`
	Currency    Currency              `json:"currency"`

	// The amount charged in fees for this withdrawal
	Fee   *WithdrawalFee    `json:"fee,omitempty"`
	State *WithdrawalStatus `json:"state,omitempty"`

	// Time in ms since 01/01/1970 (epoch)
	Timestamp *TimestampEpoch `json:"timestamp,omitempty"`

	// Unique ID for this withdrawal
	WithdrawalId *WithdrawalId `json:"withdrawalId,omitempty"`
}

// WithdrawalStatus defines model for WithdrawalStatus.
type WithdrawalStatus string

// Currency defines model for currency.
type Currency string

// expiry date in the format YYYYMMDD
type ExpireDate int

// The minimum quantity required for an IOC fill
type MinQty float64

// OrdType defines model for ordType.
type OrdType string

// The order size in the terms of the base currency
type OrderQty float64

// The limit price for the order
type Price float64

// "buy" for Buy, "sell" for Sell
type Side string

// Blockchain symbol identifier
type Symbol string

// CurrencyParam defines model for currencyParam.
type CurrencyParam Currency

// The unique execution report id assigned by the exchange
type ExecIdFromFilter ExecId

// The unique execution report id assigned by the exchange
type ExecIdToFilter ExecId

// LimitFilter defines model for limitFilter.
type LimitFilter int32

// The unique order id assigned by the exchange
type OrderIdParam ExchangeOrderId

// OrderStatusFilter defines model for orderStatusFilter.
type OrderStatusFilter OrderStatus

// Blockchain symbol identifier
type SymbolFilter Symbol

// Blockchain symbol identifier
type SymbolParam Symbol

// Time in ms since 01/01/1970 (epoch)
type TimeFromFilter TimestampEpoch

// Time in ms since 01/01/1970 (epoch)
type TimeToFilter TimestampEpoch

// GetDepositsParams defines parameters for GetDeposits.
type GetDepositsParams struct {

	// Epoch timestamp in ms
	From *TimeFromFilter `json:"from,omitempty"`

	// Epoch timestamp in ms
	To *TimeToFilter `json:"to,omitempty"`
}

// GetFillsParams defines parameters for GetFills.
type GetFillsParams struct {

	// Only return results for this symbol
	Symbol *SymbolFilter `json:"symbol,omitempty"`

	// Epoch timestamp in ms
	From *TimeFromFilter `json:"from,omitempty"`

	// List from ExecId onwards
	FromExecId *ExecIdFromFilter `json:"fromExecId,omitempty"`

	// Epoch timestamp in ms
	To *TimeToFilter `json:"to,omitempty"`

	// List from ExecId backwards
	ToExecId *ExecIdToFilter `json:"toExecId,omitempty"`

	// Maximum amount of results to return in a single call. If omitted, 100 results are returned by default.
	Limit *LimitFilter `json:"limit,omitempty"`
}

// DeleteAllOrdersParams defines parameters for DeleteAllOrders.
type DeleteAllOrdersParams struct {
	Symbol *Symbol `json:"symbol,omitempty"`
}

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {

	// Only return results for this symbol
	Symbol *SymbolFilter `json:"symbol,omitempty"`

	// Epoch timestamp in ms
	From *TimeFromFilter `json:"from,omitempty"`

	// Epoch timestamp in ms
	To *TimeToFilter `json:"to,omitempty"`

	// Order Status
	Status *OrderStatusFilter `json:"status,omitempty"`

	// Maximum amount of results to return in a single call. If omitted, 100 results are returned by default.
	Limit *LimitFilter `json:"limit,omitempty"`
}

// CreateOrderJSONBody defines parameters for CreateOrder.
type CreateOrderJSONBody BaseOrder

// GetTradesParams defines parameters for GetTrades.
type GetTradesParams struct {

	// Only return results for this symbol
	Symbol *SymbolFilter `json:"symbol,omitempty"`

	// Epoch timestamp in ms
	From *TimeFromFilter `json:"from,omitempty"`

	// Epoch timestamp in ms
	To *TimeToFilter `json:"to,omitempty"`

	// Maximum amount of results to return in a single call. If omitted, 100 results are returned by default.
	Limit *LimitFilter `json:"limit,omitempty"`
}

// GetWithdrawalsParams defines parameters for GetWithdrawals.
type GetWithdrawalsParams struct {

	// Epoch timestamp in ms
	From *TimeFromFilter `json:"from,omitempty"`

	// Epoch timestamp in ms
	To *TimeToFilter `json:"to,omitempty"`
}

// CreateWithdrawalJSONBody defines parameters for CreateWithdrawal.
type CreateWithdrawalJSONBody CreateWithdrawalRequest

// CreateOrderJSONRequestBody defines body for CreateOrder for application/json ContentType.
type CreateOrderJSONRequestBody CreateOrderJSONBody

// CreateWithdrawalJSONRequestBody defines body for CreateWithdrawal for application/json ContentType.
type CreateWithdrawalJSONRequestBody CreateWithdrawalJSONBody

// Getter for additional properties for BalanceMap. Returns the specified
// element and whether it was found
func (a BalanceMap) Get(fieldName string) (value BalanceList, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for BalanceMap
func (a *BalanceMap) Set(fieldName string, value BalanceList) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]BalanceList)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for BalanceMap to handle AdditionalProperties
func (a *BalanceMap) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["primary"]; found {
		err = json.Unmarshal(raw, &a.Primary)
		if err != nil {
			return errors.Wrap(err, "error reading 'primary'")
		}
		delete(object, "primary")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]BalanceList)
		for fieldName, fieldBuf := range object {
			var fieldVal BalanceList
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for BalanceMap to handle AdditionalProperties
func (a BalanceMap) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["primary"], err = json.Marshal(a.Primary)
	if err != nil {
		return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'primary'"))
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccounts request
	GetAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountByTypeAndCurrency request
	GetAccountByTypeAndCurrency(ctx context.Context, account string, currency CurrencyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeposits request
	GetDeposits(ctx context.Context, params *GetDepositsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDepositAddress request
	GetDepositAddress(ctx context.Context, currency CurrencyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDepositById request
	GetDepositById(ctx context.Context, depositId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFees request
	GetFees(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFills request
	GetFills(ctx context.Context, params *GetFillsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetL2OrderBook request
	GetL2OrderBook(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetL3OrderBook request
	GetL3OrderBook(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllOrders request
	DeleteAllOrders(ctx context.Context, params *DeleteAllOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrders request
	GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrder request  with any body
	CreateOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrder(ctx context.Context, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrder request
	DeleteOrder(ctx context.Context, orderId OrderIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderById request
	GetOrderById(ctx context.Context, orderId OrderIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSymbols request
	GetSymbols(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSymbolByName request
	GetSymbolByName(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTickers request
	GetTickers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTickerBySymbol request
	GetTickerBySymbol(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrades request
	GetTrades(ctx context.Context, params *GetTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWhitelist request
	GetWhitelist(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWhitelistByCurrency request
	GetWhitelistByCurrency(ctx context.Context, currency CurrencyParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWithdrawals request
	GetWithdrawals(ctx context.Context, params *GetWithdrawalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWithdrawal request  with any body
	CreateWithdrawalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWithdrawal(ctx context.Context, body CreateWithdrawalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWithdrawalById request
	GetWithdrawalById(ctx context.Context, withdrawalId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountByTypeAndCurrency(ctx context.Context, account string, currency CurrencyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountByTypeAndCurrencyRequest(c.Server, account, currency)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeposits(ctx context.Context, params *GetDepositsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepositsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDepositAddress(ctx context.Context, currency CurrencyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepositAddressRequest(c.Server, currency)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDepositById(ctx context.Context, depositId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepositByIdRequest(c.Server, depositId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFees(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFills(ctx context.Context, params *GetFillsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFillsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetL2OrderBook(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetL2OrderBookRequest(c.Server, symbol)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetL3OrderBook(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetL3OrderBookRequest(c.Server, symbol)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllOrders(ctx context.Context, params *DeleteAllOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrder(ctx context.Context, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrder(ctx context.Context, orderId OrderIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrderRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderById(ctx context.Context, orderId OrderIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderByIdRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSymbols(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSymbolsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSymbolByName(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSymbolByNameRequest(c.Server, symbol)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTickers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTickersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTickerBySymbol(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTickerBySymbolRequest(c.Server, symbol)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrades(ctx context.Context, params *GetTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTradesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWhitelist(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWhitelistRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWhitelistByCurrency(ctx context.Context, currency CurrencyParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWhitelistByCurrencyRequest(c.Server, currency)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWithdrawals(ctx context.Context, params *GetWithdrawalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWithdrawalsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWithdrawalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWithdrawalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWithdrawal(ctx context.Context, body CreateWithdrawalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWithdrawalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWithdrawalById(ctx context.Context, withdrawalId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWithdrawalByIdRequest(c.Server, withdrawalId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountsRequest generates requests for GetAccounts
func NewGetAccountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountByTypeAndCurrencyRequest generates requests for GetAccountByTypeAndCurrency
func NewGetAccountByTypeAndCurrencyRequest(server string, account string, currency CurrencyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account", runtime.ParamLocationPath, account)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "currency", runtime.ParamLocationPath, currency)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepositsRequest generates requests for GetDeposits
func NewGetDepositsRequest(server string, params *GetDepositsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deposits")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.To != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepositAddressRequest generates requests for GetDepositAddress
func NewGetDepositAddressRequest(server string, currency CurrencyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "currency", runtime.ParamLocationPath, currency)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deposits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepositByIdRequest generates requests for GetDepositById
func NewGetDepositByIdRequest(server string, depositId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "depositId", runtime.ParamLocationPath, depositId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deposits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeesRequest generates requests for GetFees
func NewGetFeesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fees")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFillsRequest generates requests for GetFills
func NewGetFillsRequest(server string, params *GetFillsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fills")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FromExecId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromExecId", runtime.ParamLocationQuery, *params.FromExecId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.To != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToExecId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toExecId", runtime.ParamLocationQuery, *params.ToExecId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetL2OrderBookRequest generates requests for GetL2OrderBook
func NewGetL2OrderBookRequest(server string, symbol SymbolParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/l2/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetL3OrderBookRequest generates requests for GetL3OrderBook
func NewGetL3OrderBookRequest(server string, symbol SymbolParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/l3/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAllOrdersRequest generates requests for DeleteAllOrders
func NewDeleteAllOrdersRequest(server string, params *DeleteAllOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrdersRequest generates requests for GetOrders
func NewGetOrdersRequest(server string, params *GetOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.To != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrderRequest calls the generic CreateOrder builder with application/json body
func NewCreateOrderRequest(server string, body CreateOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOrderRequestWithBody generates requests for CreateOrder with any type of body
func NewCreateOrderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrderRequest generates requests for DeleteOrder
func NewDeleteOrderRequest(server string, orderId OrderIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderByIdRequest generates requests for GetOrderById
func NewGetOrderByIdRequest(server string, orderId OrderIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSymbolsRequest generates requests for GetSymbols
func NewGetSymbolsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/symbols")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSymbolByNameRequest generates requests for GetSymbolByName
func NewGetSymbolByNameRequest(server string, symbol SymbolParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/symbols/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTickersRequest generates requests for GetTickers
func NewGetTickersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTickerBySymbolRequest generates requests for GetTickerBySymbol
func NewGetTickerBySymbolRequest(server string, symbol SymbolParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTradesRequest generates requests for GetTrades
func NewGetTradesRequest(server string, params *GetTradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trades")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.To != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWhitelistRequest generates requests for GetWhitelist
func NewGetWhitelistRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whitelist")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWhitelistByCurrencyRequest generates requests for GetWhitelistByCurrency
func NewGetWhitelistByCurrencyRequest(server string, currency CurrencyParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "currency", runtime.ParamLocationPath, currency)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whitelist/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWithdrawalsRequest generates requests for GetWithdrawals
func NewGetWithdrawalsRequest(server string, params *GetWithdrawalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/withdrawals")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.To != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWithdrawalRequest calls the generic CreateWithdrawal builder with application/json body
func NewCreateWithdrawalRequest(server string, body CreateWithdrawalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWithdrawalRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWithdrawalRequestWithBody generates requests for CreateWithdrawal with any type of body
func NewCreateWithdrawalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/withdrawals")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWithdrawalByIdRequest generates requests for GetWithdrawalById
func NewGetWithdrawalByIdRequest(server string, withdrawalId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "withdrawalId", runtime.ParamLocationPath, withdrawalId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/withdrawals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccounts request
	GetAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error)

	// GetAccountByTypeAndCurrency request
	GetAccountByTypeAndCurrencyWithResponse(ctx context.Context, account string, currency CurrencyParam, reqEditors ...RequestEditorFn) (*GetAccountByTypeAndCurrencyResponse, error)

	// GetDeposits request
	GetDepositsWithResponse(ctx context.Context, params *GetDepositsParams, reqEditors ...RequestEditorFn) (*GetDepositsResponse, error)

	// GetDepositAddress request
	GetDepositAddressWithResponse(ctx context.Context, currency CurrencyParam, reqEditors ...RequestEditorFn) (*GetDepositAddressResponse, error)

	// GetDepositById request
	GetDepositByIdWithResponse(ctx context.Context, depositId string, reqEditors ...RequestEditorFn) (*GetDepositByIdResponse, error)

	// GetFees request
	GetFeesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFeesResponse, error)

	// GetFills request
	GetFillsWithResponse(ctx context.Context, params *GetFillsParams, reqEditors ...RequestEditorFn) (*GetFillsResponse, error)

	// GetL2OrderBook request
	GetL2OrderBookWithResponse(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*GetL2OrderBookResponse, error)

	// GetL3OrderBook request
	GetL3OrderBookWithResponse(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*GetL3OrderBookResponse, error)

	// DeleteAllOrders request
	DeleteAllOrdersWithResponse(ctx context.Context, params *DeleteAllOrdersParams, reqEditors ...RequestEditorFn) (*DeleteAllOrdersResponse, error)

	// GetOrders request
	GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResponse, error)

	// CreateOrder request  with any body
	CreateOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error)

	CreateOrderWithResponse(ctx context.Context, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error)

	// DeleteOrder request
	DeleteOrderWithResponse(ctx context.Context, orderId OrderIdParam, reqEditors ...RequestEditorFn) (*DeleteOrderResponse, error)

	// GetOrderById request
	GetOrderByIdWithResponse(ctx context.Context, orderId OrderIdParam, reqEditors ...RequestEditorFn) (*GetOrderByIdResponse, error)

	// GetSymbols request
	GetSymbolsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSymbolsResponse, error)

	// GetSymbolByName request
	GetSymbolByNameWithResponse(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*GetSymbolByNameResponse, error)

	// GetTickers request
	GetTickersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTickersResponse, error)

	// GetTickerBySymbol request
	GetTickerBySymbolWithResponse(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*GetTickerBySymbolResponse, error)

	// GetTrades request
	GetTradesWithResponse(ctx context.Context, params *GetTradesParams, reqEditors ...RequestEditorFn) (*GetTradesResponse, error)

	// GetWhitelist request
	GetWhitelistWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWhitelistResponse, error)

	// GetWhitelistByCurrency request
	GetWhitelistByCurrencyWithResponse(ctx context.Context, currency CurrencyParam, reqEditors ...RequestEditorFn) (*GetWhitelistByCurrencyResponse, error)

	// GetWithdrawals request
	GetWithdrawalsWithResponse(ctx context.Context, params *GetWithdrawalsParams, reqEditors ...RequestEditorFn) (*GetWithdrawalsResponse, error)

	// CreateWithdrawal request  with any body
	CreateWithdrawalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWithdrawalResponse, error)

	CreateWithdrawalWithResponse(ctx context.Context, body CreateWithdrawalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWithdrawalResponse, error)

	// GetWithdrawalById request
	GetWithdrawalByIdWithResponse(ctx context.Context, withdrawalId string, reqEditors ...RequestEditorFn) (*GetWithdrawalByIdResponse, error)
}

type GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BalanceMap
}

// Status returns HTTPResponse.Status
func (r GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountByTypeAndCurrencyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Balance
}

// Status returns HTTPResponse.Status
func (r GetAccountByTypeAndCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountByTypeAndCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDepositsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DepositInfo
}

// Status returns HTTPResponse.Status
func (r GetDepositsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepositsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDepositAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepositAddressCrypto
}

// Status returns HTTPResponse.Status
func (r GetDepositAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepositAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDepositByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepositInfo
}

// Status returns HTTPResponse.Status
func (r GetDepositByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepositByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Fees
}

// Status returns HTTPResponse.Status
func (r GetFeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFillsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Fill
}

// Status returns HTTPResponse.Status
func (r GetFillsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFillsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetL2OrderBookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderBook
}

// Status returns HTTPResponse.Status
func (r GetL2OrderBookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetL2OrderBookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetL3OrderBookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderBook
}

// Status returns HTTPResponse.Status
func (r GetL3OrderBookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetL3OrderBookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAllOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrderSummary
}

// Status returns HTTPResponse.Status
func (r GetOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderSummary
}

// Status returns HTTPResponse.Status
func (r CreateOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderSummary
}

// Status returns HTTPResponse.Status
func (r GetOrderByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSymbolsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]SymbolStatus `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSymbolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSymbolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSymbolByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SymbolStatus
}

// Status returns HTTPResponse.Status
func (r GetSymbolByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSymbolByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PriceEvent
}

// Status returns HTTPResponse.Status
func (r GetTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTickerBySymbolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PriceEvent
}

// Status returns HTTPResponse.Status
func (r GetTickerBySymbolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTickerBySymbolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrderSummary
}

// Status returns HTTPResponse.Status
func (r GetTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWhitelistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WhitelistEntry
}

// Status returns HTTPResponse.Status
func (r GetWhitelistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWhitelistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWhitelistByCurrencyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WhitelistEntry
}

// Status returns HTTPResponse.Status
func (r GetWhitelistByCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWhitelistByCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWithdrawalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WithdrawalInfo
}

// Status returns HTTPResponse.Status
func (r GetWithdrawalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWithdrawalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWithdrawalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WithdrawalInfo
}

// Status returns HTTPResponse.Status
func (r CreateWithdrawalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWithdrawalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWithdrawalByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WithdrawalInfo
}

// Status returns HTTPResponse.Status
func (r GetWithdrawalByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWithdrawalByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountsWithResponse request returning *GetAccountsResponse
func (c *ClientWithResponses) GetAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error) {
	rsp, err := c.GetAccounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsResponse(rsp)
}

// GetAccountByTypeAndCurrencyWithResponse request returning *GetAccountByTypeAndCurrencyResponse
func (c *ClientWithResponses) GetAccountByTypeAndCurrencyWithResponse(ctx context.Context, account string, currency CurrencyParam, reqEditors ...RequestEditorFn) (*GetAccountByTypeAndCurrencyResponse, error) {
	rsp, err := c.GetAccountByTypeAndCurrency(ctx, account, currency, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountByTypeAndCurrencyResponse(rsp)
}

// GetDepositsWithResponse request returning *GetDepositsResponse
func (c *ClientWithResponses) GetDepositsWithResponse(ctx context.Context, params *GetDepositsParams, reqEditors ...RequestEditorFn) (*GetDepositsResponse, error) {
	rsp, err := c.GetDeposits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepositsResponse(rsp)
}

// GetDepositAddressWithResponse request returning *GetDepositAddressResponse
func (c *ClientWithResponses) GetDepositAddressWithResponse(ctx context.Context, currency CurrencyParam, reqEditors ...RequestEditorFn) (*GetDepositAddressResponse, error) {
	rsp, err := c.GetDepositAddress(ctx, currency, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepositAddressResponse(rsp)
}

// GetDepositByIdWithResponse request returning *GetDepositByIdResponse
func (c *ClientWithResponses) GetDepositByIdWithResponse(ctx context.Context, depositId string, reqEditors ...RequestEditorFn) (*GetDepositByIdResponse, error) {
	rsp, err := c.GetDepositById(ctx, depositId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepositByIdResponse(rsp)
}

// GetFeesWithResponse request returning *GetFeesResponse
func (c *ClientWithResponses) GetFeesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFeesResponse, error) {
	rsp, err := c.GetFees(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeesResponse(rsp)
}

// GetFillsWithResponse request returning *GetFillsResponse
func (c *ClientWithResponses) GetFillsWithResponse(ctx context.Context, params *GetFillsParams, reqEditors ...RequestEditorFn) (*GetFillsResponse, error) {
	rsp, err := c.GetFills(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFillsResponse(rsp)
}

// GetL2OrderBookWithResponse request returning *GetL2OrderBookResponse
func (c *ClientWithResponses) GetL2OrderBookWithResponse(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*GetL2OrderBookResponse, error) {
	rsp, err := c.GetL2OrderBook(ctx, symbol, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetL2OrderBookResponse(rsp)
}

// GetL3OrderBookWithResponse request returning *GetL3OrderBookResponse
func (c *ClientWithResponses) GetL3OrderBookWithResponse(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*GetL3OrderBookResponse, error) {
	rsp, err := c.GetL3OrderBook(ctx, symbol, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetL3OrderBookResponse(rsp)
}

// DeleteAllOrdersWithResponse request returning *DeleteAllOrdersResponse
func (c *ClientWithResponses) DeleteAllOrdersWithResponse(ctx context.Context, params *DeleteAllOrdersParams, reqEditors ...RequestEditorFn) (*DeleteAllOrdersResponse, error) {
	rsp, err := c.DeleteAllOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllOrdersResponse(rsp)
}

// GetOrdersWithResponse request returning *GetOrdersResponse
func (c *ClientWithResponses) GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResponse, error) {
	rsp, err := c.GetOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersResponse(rsp)
}

// CreateOrderWithBodyWithResponse request with arbitrary body returning *CreateOrderResponse
func (c *ClientWithResponses) CreateOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error) {
	rsp, err := c.CreateOrderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrderResponse(rsp)
}

func (c *ClientWithResponses) CreateOrderWithResponse(ctx context.Context, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error) {
	rsp, err := c.CreateOrder(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrderResponse(rsp)
}

// DeleteOrderWithResponse request returning *DeleteOrderResponse
func (c *ClientWithResponses) DeleteOrderWithResponse(ctx context.Context, orderId OrderIdParam, reqEditors ...RequestEditorFn) (*DeleteOrderResponse, error) {
	rsp, err := c.DeleteOrder(ctx, orderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrderResponse(rsp)
}

// GetOrderByIdWithResponse request returning *GetOrderByIdResponse
func (c *ClientWithResponses) GetOrderByIdWithResponse(ctx context.Context, orderId OrderIdParam, reqEditors ...RequestEditorFn) (*GetOrderByIdResponse, error) {
	rsp, err := c.GetOrderById(ctx, orderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderByIdResponse(rsp)
}

// GetSymbolsWithResponse request returning *GetSymbolsResponse
func (c *ClientWithResponses) GetSymbolsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSymbolsResponse, error) {
	rsp, err := c.GetSymbols(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSymbolsResponse(rsp)
}

// GetSymbolByNameWithResponse request returning *GetSymbolByNameResponse
func (c *ClientWithResponses) GetSymbolByNameWithResponse(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*GetSymbolByNameResponse, error) {
	rsp, err := c.GetSymbolByName(ctx, symbol, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSymbolByNameResponse(rsp)
}

// GetTickersWithResponse request returning *GetTickersResponse
func (c *ClientWithResponses) GetTickersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTickersResponse, error) {
	rsp, err := c.GetTickers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTickersResponse(rsp)
}

// GetTickerBySymbolWithResponse request returning *GetTickerBySymbolResponse
func (c *ClientWithResponses) GetTickerBySymbolWithResponse(ctx context.Context, symbol SymbolParam, reqEditors ...RequestEditorFn) (*GetTickerBySymbolResponse, error) {
	rsp, err := c.GetTickerBySymbol(ctx, symbol, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTickerBySymbolResponse(rsp)
}

// GetTradesWithResponse request returning *GetTradesResponse
func (c *ClientWithResponses) GetTradesWithResponse(ctx context.Context, params *GetTradesParams, reqEditors ...RequestEditorFn) (*GetTradesResponse, error) {
	rsp, err := c.GetTrades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTradesResponse(rsp)
}

// GetWhitelistWithResponse request returning *GetWhitelistResponse
func (c *ClientWithResponses) GetWhitelistWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWhitelistResponse, error) {
	rsp, err := c.GetWhitelist(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWhitelistResponse(rsp)
}

// GetWhitelistByCurrencyWithResponse request returning *GetWhitelistByCurrencyResponse
func (c *ClientWithResponses) GetWhitelistByCurrencyWithResponse(ctx context.Context, currency CurrencyParam, reqEditors ...RequestEditorFn) (*GetWhitelistByCurrencyResponse, error) {
	rsp, err := c.GetWhitelistByCurrency(ctx, currency, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWhitelistByCurrencyResponse(rsp)
}

// GetWithdrawalsWithResponse request returning *GetWithdrawalsResponse
func (c *ClientWithResponses) GetWithdrawalsWithResponse(ctx context.Context, params *GetWithdrawalsParams, reqEditors ...RequestEditorFn) (*GetWithdrawalsResponse, error) {
	rsp, err := c.GetWithdrawals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWithdrawalsResponse(rsp)
}

// CreateWithdrawalWithBodyWithResponse request with arbitrary body returning *CreateWithdrawalResponse
func (c *ClientWithResponses) CreateWithdrawalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWithdrawalResponse, error) {
	rsp, err := c.CreateWithdrawalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWithdrawalResponse(rsp)
}

func (c *ClientWithResponses) CreateWithdrawalWithResponse(ctx context.Context, body CreateWithdrawalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWithdrawalResponse, error) {
	rsp, err := c.CreateWithdrawal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWithdrawalResponse(rsp)
}

// GetWithdrawalByIdWithResponse request returning *GetWithdrawalByIdResponse
func (c *ClientWithResponses) GetWithdrawalByIdWithResponse(ctx context.Context, withdrawalId string, reqEditors ...RequestEditorFn) (*GetWithdrawalByIdResponse, error) {
	rsp, err := c.GetWithdrawalById(ctx, withdrawalId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWithdrawalByIdResponse(rsp)
}

// ParseGetAccountsResponse parses an HTTP response from a GetAccountsWithResponse call
func ParseGetAccountsResponse(rsp *http.Response) (*GetAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BalanceMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccountByTypeAndCurrencyResponse parses an HTTP response from a GetAccountByTypeAndCurrencyWithResponse call
func ParseGetAccountByTypeAndCurrencyResponse(rsp *http.Response) (*GetAccountByTypeAndCurrencyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAccountByTypeAndCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Balance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDepositsResponse parses an HTTP response from a GetDepositsWithResponse call
func ParseGetDepositsResponse(rsp *http.Response) (*GetDepositsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDepositsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DepositInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDepositAddressResponse parses an HTTP response from a GetDepositAddressWithResponse call
func ParseGetDepositAddressResponse(rsp *http.Response) (*GetDepositAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDepositAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepositAddressCrypto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDepositByIdResponse parses an HTTP response from a GetDepositByIdWithResponse call
func ParseGetDepositByIdResponse(rsp *http.Response) (*GetDepositByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDepositByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepositInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFeesResponse parses an HTTP response from a GetFeesWithResponse call
func ParseGetFeesResponse(rsp *http.Response) (*GetFeesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetFeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Fees
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFillsResponse parses an HTTP response from a GetFillsWithResponse call
func ParseGetFillsResponse(rsp *http.Response) (*GetFillsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetFillsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Fill
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetL2OrderBookResponse parses an HTTP response from a GetL2OrderBookWithResponse call
func ParseGetL2OrderBookResponse(rsp *http.Response) (*GetL2OrderBookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetL2OrderBookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderBook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetL3OrderBookResponse parses an HTTP response from a GetL3OrderBookWithResponse call
func ParseGetL3OrderBookResponse(rsp *http.Response) (*GetL3OrderBookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetL3OrderBookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderBook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAllOrdersResponse parses an HTTP response from a DeleteAllOrdersWithResponse call
func ParseDeleteAllOrdersResponse(rsp *http.Response) (*DeleteAllOrdersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetOrdersResponse parses an HTTP response from a GetOrdersWithResponse call
func ParseGetOrdersResponse(rsp *http.Response) (*GetOrdersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrderSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateOrderResponse parses an HTTP response from a CreateOrderWithResponse call
func ParseCreateOrderResponse(rsp *http.Response) (*CreateOrderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOrderResponse parses an HTTP response from a DeleteOrderWithResponse call
func ParseDeleteOrderResponse(rsp *http.Response) (*DeleteOrderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetOrderByIdResponse parses an HTTP response from a GetOrderByIdWithResponse call
func ParseGetOrderByIdResponse(rsp *http.Response) (*GetOrderByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetOrderByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSymbolsResponse parses an HTTP response from a GetSymbolsWithResponse call
func ParseGetSymbolsResponse(rsp *http.Response) (*GetSymbolsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSymbolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]SymbolStatus `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSymbolByNameResponse parses an HTTP response from a GetSymbolByNameWithResponse call
func ParseGetSymbolByNameResponse(rsp *http.Response) (*GetSymbolByNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSymbolByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SymbolStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTickersResponse parses an HTTP response from a GetTickersWithResponse call
func ParseGetTickersResponse(rsp *http.Response) (*GetTickersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PriceEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTickerBySymbolResponse parses an HTTP response from a GetTickerBySymbolWithResponse call
func ParseGetTickerBySymbolResponse(rsp *http.Response) (*GetTickerBySymbolResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTickerBySymbolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PriceEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTradesResponse parses an HTTP response from a GetTradesWithResponse call
func ParseGetTradesResponse(rsp *http.Response) (*GetTradesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrderSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWhitelistResponse parses an HTTP response from a GetWhitelistWithResponse call
func ParseGetWhitelistResponse(rsp *http.Response) (*GetWhitelistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetWhitelistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WhitelistEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWhitelistByCurrencyResponse parses an HTTP response from a GetWhitelistByCurrencyWithResponse call
func ParseGetWhitelistByCurrencyResponse(rsp *http.Response) (*GetWhitelistByCurrencyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetWhitelistByCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WhitelistEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWithdrawalsResponse parses an HTTP response from a GetWithdrawalsWithResponse call
func ParseGetWithdrawalsResponse(rsp *http.Response) (*GetWithdrawalsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetWithdrawalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WithdrawalInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWithdrawalResponse parses an HTTP response from a CreateWithdrawalWithResponse call
func ParseCreateWithdrawalResponse(rsp *http.Response) (*CreateWithdrawalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateWithdrawalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WithdrawalInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWithdrawalByIdResponse parses an HTTP response from a GetWithdrawalByIdWithResponse call
func ParseGetWithdrawalByIdResponse(rsp *http.Response) (*GetWithdrawalByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetWithdrawalByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WithdrawalInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Receive current account balances
	// (GET /accounts)
	GetAccounts(ctx echo.Context) error
	// Receive current account balances
	// (GET /accounts/{account}/{currency})
	GetAccountByTypeAndCurrency(ctx echo.Context, account string, currency CurrencyParam) error
	// Get a list of deposits
	// (GET /deposits)
	GetDeposits(ctx echo.Context, params GetDepositsParams) error
	// Get a deposit address. Currently only crypto currencies are supported
	// (POST /deposits/{currency})
	GetDepositAddress(ctx echo.Context, currency CurrencyParam) error
	// Get status about a deposit
	// (GET /deposits/{depositId})
	GetDepositById(ctx echo.Context, depositId string) error
	// Get current fee level
	// (GET /fees)
	GetFees(ctx echo.Context) error
	// Get a list of fills
	// (GET /fills)
	GetFills(ctx echo.Context, params GetFillsParams) error
	// L2 Order Book
	// (GET /l2/{symbol})
	GetL2OrderBook(ctx echo.Context, symbol SymbolParam) error
	// L3 Order Book
	// (GET /l3/{symbol})
	GetL3OrderBook(ctx echo.Context, symbol SymbolParam) error
	// Delete all open orders (of a symbol, if specified)
	// (DELETE /orders)
	DeleteAllOrders(ctx echo.Context, params DeleteAllOrdersParams) error
	// Get a list orders
	// (GET /orders)
	GetOrders(ctx echo.Context, params GetOrdersParams) error
	// Add an order
	// (POST /orders)
	CreateOrder(ctx echo.Context) error
	// Cancel a trade
	// (DELETE /orders/{orderId})
	DeleteOrder(ctx echo.Context, orderId OrderIdParam) error
	// Get a specific order
	// (GET /orders/{orderId})
	GetOrderById(ctx echo.Context, orderId OrderIdParam) error
	// Symbols
	// (GET /symbols)
	GetSymbols(ctx echo.Context) error
	// Symbols
	// (GET /symbols/{symbol})
	GetSymbolByName(ctx echo.Context, symbol SymbolParam) error
	// Price
	// (GET /tickers)
	GetTickers(ctx echo.Context) error
	// Price
	// (GET /tickers/{symbol})
	GetTickerBySymbol(ctx echo.Context, symbol SymbolParam) error
	// Get a list of filled orders
	// (GET /trades)
	GetTrades(ctx echo.Context, params GetTradesParams) error
	// Get a list of all whitelisted withdrawal accounts
	// (GET /whitelist)
	GetWhitelist(ctx echo.Context) error
	// Get a list of all whitelisted withdrawal accounts
	// (GET /whitelist/{currency})
	GetWhitelistByCurrency(ctx echo.Context, currency CurrencyParam) error
	// Get a list of withdrawals
	// (GET /withdrawals)
	GetWithdrawals(ctx echo.Context, params GetWithdrawalsParams) error
	// Request a withdrawal
	// (POST /withdrawals)
	CreateWithdrawal(ctx echo.Context) error
	// Get status about a withdrawal
	// (GET /withdrawals/{withdrawalId})
	GetWithdrawalById(ctx echo.Context, withdrawalId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAccounts(ctx)
	return err
}

// GetAccountByTypeAndCurrency converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccountByTypeAndCurrency(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account", runtime.ParamLocationPath, ctx.Param("account"), &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	// ------------- Path parameter "currency" -------------
	var currency CurrencyParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "currency", runtime.ParamLocationPath, ctx.Param("currency"), &currency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAccountByTypeAndCurrency(ctx, account, currency)
	return err
}

// GetDeposits converts echo context to params.
func (w *ServerInterfaceWrapper) GetDeposits(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDepositsParams
	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDeposits(ctx, params)
	return err
}

// GetDepositAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetDepositAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "currency" -------------
	var currency CurrencyParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "currency", runtime.ParamLocationPath, ctx.Param("currency"), &currency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDepositAddress(ctx, currency)
	return err
}

// GetDepositById converts echo context to params.
func (w *ServerInterfaceWrapper) GetDepositById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "depositId" -------------
	var depositId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "depositId", runtime.ParamLocationPath, ctx.Param("depositId"), &depositId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter depositId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDepositById(ctx, depositId)
	return err
}

// GetFees converts echo context to params.
func (w *ServerInterfaceWrapper) GetFees(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFees(ctx)
	return err
}

// GetFills converts echo context to params.
func (w *ServerInterfaceWrapper) GetFills(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFillsParams
	// ------------- Optional query parameter "symbol" -------------

	err = runtime.BindQueryParameter("form", true, false, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "fromExecId" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromExecId", ctx.QueryParams(), &params.FromExecId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fromExecId: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Optional query parameter "toExecId" -------------

	err = runtime.BindQueryParameter("form", true, false, "toExecId", ctx.QueryParams(), &params.ToExecId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter toExecId: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFills(ctx, params)
	return err
}

// GetL2OrderBook converts echo context to params.
func (w *ServerInterfaceWrapper) GetL2OrderBook(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "symbol" -------------
	var symbol SymbolParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "symbol", runtime.ParamLocationPath, ctx.Param("symbol"), &symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetL2OrderBook(ctx, symbol)
	return err
}

// GetL3OrderBook converts echo context to params.
func (w *ServerInterfaceWrapper) GetL3OrderBook(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "symbol" -------------
	var symbol SymbolParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "symbol", runtime.ParamLocationPath, ctx.Param("symbol"), &symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetL3OrderBook(ctx, symbol)
	return err
}

// DeleteAllOrders converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAllOrders(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAllOrdersParams
	// ------------- Optional query parameter "symbol" -------------

	err = runtime.BindQueryParameter("form", true, false, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteAllOrders(ctx, params)
	return err
}

// GetOrders converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrders(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrdersParams
	// ------------- Optional query parameter "symbol" -------------

	err = runtime.BindQueryParameter("form", true, false, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOrders(ctx, params)
	return err
}

// CreateOrder converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOrder(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateOrder(ctx)
	return err
}

// DeleteOrder converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "orderId" -------------
	var orderId OrderIdParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "orderId", runtime.ParamLocationPath, ctx.Param("orderId"), &orderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteOrder(ctx, orderId)
	return err
}

// GetOrderById converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrderById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "orderId" -------------
	var orderId OrderIdParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "orderId", runtime.ParamLocationPath, ctx.Param("orderId"), &orderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOrderById(ctx, orderId)
	return err
}

// GetSymbols converts echo context to params.
func (w *ServerInterfaceWrapper) GetSymbols(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSymbols(ctx)
	return err
}

// GetSymbolByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetSymbolByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "symbol" -------------
	var symbol SymbolParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "symbol", runtime.ParamLocationPath, ctx.Param("symbol"), &symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSymbolByName(ctx, symbol)
	return err
}

// GetTickers converts echo context to params.
func (w *ServerInterfaceWrapper) GetTickers(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTickers(ctx)
	return err
}

// GetTickerBySymbol converts echo context to params.
func (w *ServerInterfaceWrapper) GetTickerBySymbol(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "symbol" -------------
	var symbol SymbolParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "symbol", runtime.ParamLocationPath, ctx.Param("symbol"), &symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTickerBySymbol(ctx, symbol)
	return err
}

// GetTrades converts echo context to params.
func (w *ServerInterfaceWrapper) GetTrades(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTradesParams
	// ------------- Optional query parameter "symbol" -------------

	err = runtime.BindQueryParameter("form", true, false, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTrades(ctx, params)
	return err
}

// GetWhitelist converts echo context to params.
func (w *ServerInterfaceWrapper) GetWhitelist(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetWhitelist(ctx)
	return err
}

// GetWhitelistByCurrency converts echo context to params.
func (w *ServerInterfaceWrapper) GetWhitelistByCurrency(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "currency" -------------
	var currency CurrencyParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "currency", runtime.ParamLocationPath, ctx.Param("currency"), &currency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetWhitelistByCurrency(ctx, currency)
	return err
}

// GetWithdrawals converts echo context to params.
func (w *ServerInterfaceWrapper) GetWithdrawals(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWithdrawalsParams
	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetWithdrawals(ctx, params)
	return err
}

// CreateWithdrawal converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWithdrawal(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateWithdrawal(ctx)
	return err
}

// GetWithdrawalById converts echo context to params.
func (w *ServerInterfaceWrapper) GetWithdrawalById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "withdrawalId" -------------
	var withdrawalId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "withdrawalId", runtime.ParamLocationPath, ctx.Param("withdrawalId"), &withdrawalId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter withdrawalId: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetWithdrawalById(ctx, withdrawalId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/accounts", wrapper.GetAccounts)
	router.GET(baseURL+"/accounts/:account/:currency", wrapper.GetAccountByTypeAndCurrency)
	router.GET(baseURL+"/deposits", wrapper.GetDeposits)
	router.POST(baseURL+"/deposits/:currency", wrapper.GetDepositAddress)
	router.GET(baseURL+"/deposits/:depositId", wrapper.GetDepositById)
	router.GET(baseURL+"/fees", wrapper.GetFees)
	router.GET(baseURL+"/fills", wrapper.GetFills)
	router.GET(baseURL+"/l2/:symbol", wrapper.GetL2OrderBook)
	router.GET(baseURL+"/l3/:symbol", wrapper.GetL3OrderBook)
	router.DELETE(baseURL+"/orders", wrapper.DeleteAllOrders)
	router.GET(baseURL+"/orders", wrapper.GetOrders)
	router.POST(baseURL+"/orders", wrapper.CreateOrder)
	router.DELETE(baseURL+"/orders/:orderId", wrapper.DeleteOrder)
	router.GET(baseURL+"/orders/:orderId", wrapper.GetOrderById)
	router.GET(baseURL+"/symbols", wrapper.GetSymbols)
	router.GET(baseURL+"/symbols/:symbol", wrapper.GetSymbolByName)
	router.GET(baseURL+"/tickers", wrapper.GetTickers)
	router.GET(baseURL+"/tickers/:symbol", wrapper.GetTickerBySymbol)
	router.GET(baseURL+"/trades", wrapper.GetTrades)
	router.GET(baseURL+"/whitelist", wrapper.GetWhitelist)
	router.GET(baseURL+"/whitelist/:currency", wrapper.GetWhitelistByCurrency)
	router.GET(baseURL+"/withdrawals", wrapper.GetWithdrawals)
	router.POST(baseURL+"/withdrawals", wrapper.CreateWithdrawal)
	router.GET(baseURL+"/withdrawals/:withdrawalId", wrapper.GetWithdrawalById)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"H2IAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

